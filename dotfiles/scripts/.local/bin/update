#!/usr/bin/env bash

set -euo pipefail

NIX_CONFIG_PATH="${HOME}/.nix-config"
ARCH=""
OS=""

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Helper functions for colored output
function echo_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  ${1}${NC}"
}

function echo_success() {
    echo -e "${GREEN}‚úÖ ${1}${NC}"
}

function echo_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  ${1}${NC}"
}

function echo_error() {
    echo -e "${RED}‚ùå ${1}${NC}"
}

function echo_header() {
    echo -e "${BOLD}${CYAN}üöÄ ${1}${NC}"
}

function detect_system() {
    ARCH=$(uname -m)
    case "$ARCH" in
        x86_64) ARCH="x86_64" ;;
        aarch64 | arm64) ARCH="aarch64" ;;
        *)
            echo_error "Unsupported architecture: $ARCH"
            exit 1
            ;;
    esac

    if [[ $OSTYPE == "linux-gnu"* ]]; then
        if grep -q "Ubuntu" /etc/os-release 2> /dev/null; then
            OS="ubuntu"
        elif grep -q "Debian" /etc/os-release 2> /dev/null; then
            OS="debian"
        elif grep -q "NixOS" /etc/os-release 2> /dev/null; then
            OS="nixos"
        else
            echo_error "Unsupported Linux distribution. Only Ubuntu, Debian, and NixOS are supported."
            exit 1
        fi
    elif [[ $OSTYPE == "darwin"* ]]; then
        OS="darwin"
    else
        echo_error "Unsupported operating system: $OSTYPE"
        exit 1
    fi
}

detect_system

function pushd() {
    command pushd "$@" > /dev/null
}

function popd() {
    command popd "$@" > /dev/null
}

function tool:config {
    echo_header "Updating config"
    pushd "$NIX_CONFIG_PATH"

    local current_branch=$(git branch --show-current)
    if [[ "$current_branch" != "main" ]]; then
        echo_warning "Not on main branch ($current_branch), skipping config update"
        popd
        return
    fi

    echo_info "Stashing local changes..."
    git stash || true
    echo_info "Pulling latest changes..."
    git pull
    echo_info "Restoring local changes..."
    git stash pop || true
    echo_success "Config updated"
    popd
}

function tool:nvim {
    if command -v nvim &> /dev/null; then
        echo_header "Updating neovim plugins"
        echo_info "Updating TreeSitter parsers..."
        nvim --headless "+TSUpdateSync" +qa
        echo_info "Syncing Lazy plugins..."
        nvim --headless "+Lazy! sync" +qa
        echo_success "Neovim plugins updated"
    else
        echo_warning "Neovim not found, skipping plugin updates"
    fi
}

function tool:nvim:clean {
    if command -v nvim &> /dev/null; then
        echo_header "Cleaning neovim plugins"
        nvim --headless "+Lazy! clean" +qa
        echo_success "Neovim plugins cleaned"
        # echo_info "Clearing watchman watches..."
        # watchman watch-del-all # clear watchman watches for nvim plugins
    else
        echo_warning "Neovim not found, skipping plugin cleanup"
    fi
}

function tool:nvim:restore {
    if command -v nvim &> /dev/null; then
        echo_header "Restoring neovim plugins"
        nvim --headless "+Lazy! restore" +qa
        echo_success "Neovim plugins restored"
    else
        echo_warning "Neovim not found, skipping plugin restore"
    fi
}

function tool:nix {
    echo_header "Updating nix"
    tool:nix:flake
    tool:pkgs:update "$@"
    tool:nix:rebuild
    echo_success "Nix update complete"
}

function tool:nix:flake {
    echo_header "Updating flake.lock"
    pushd "$NIX_CONFIG_PATH"
    nix flake update
    echo_success "Flake.lock updated"
    popd
}

function tool:nix:clean {
    echo_header "Cleaning nix store"
    echo_info "Cleaning user nix store..."
    nix-collect-garbage --delete-older-than 7d
    echo_info "Cleaning root nix store..."
    sudo nix-collect-garbage --delete-older-than 7d
    echo_success "Nix store cleaned"
}

function tool:nix:rebuild {
    echo_header "Rebuilding nix config"

    case "$OS" in
        ubuntu | debian)
            echo_info "Detected $OS, using home-manager switch..."
            home-manager switch --flake "$NIX_CONFIG_PATH"
            ;;
        darwin)
            echo_info "Detected macOS, using darwin-rebuild..."
            sudo darwin-rebuild switch --flake "$NIX_CONFIG_PATH"
            ;;
        nixos)
            echo_info "Detected NixOS, using nixos-rebuild..."
            sudo nixos-rebuild switch --flake "$NIX_CONFIG_PATH"
            ;;
        *)
            echo_error "Unsupported system configuration: $OS"
            exit 1
            ;;
    esac
    tool:fish
    echo_success "Nix config rebuilt"
}

function tool:pkgs:hashes() {
    local operation_name="${1:-manual operation}"
    shift || true
    local target_items=("$@")

    # If specific items are provided, construct file list directly
    if [[ ${#target_items[@]} -gt 0 ]]; then
        changed_files=()
        for item in "${target_items[@]}"; do
            # Convert dot notation to path (e.g., "fish-plugins.upto" -> "fish-plugins/upto")
            item_path="${item//\.//}"
            # Look for the item's nix files
            if [[ -d "pkgs/$item_path" ]]; then
                while IFS= read -r -d '' file; do
                    changed_files+=("$file")
                done < <(find "pkgs/$item_path" -name "*.nix" -print0)
            fi
        done
    else
        # Get list of files that were changed
        changed_files=($(git diff --name-only pkgs/ | grep '\.nix$' || true))
    fi

    if [[ ${#changed_files[@]} -gt 0 ]]; then
        echo_info "Updating hashes for ${#changed_files[@]} changed files..."
        for file in "${changed_files[@]}"; do
            echo_info "Checking hashes for $file"

            # Try to build the package and capture any hash mismatches
            build_output=$(timeout 300 nix-build -E "with import <nixpkgs> {}; callPackage ./$file {}" 2>&1 || true)

            # Extract hash mismatches and replace them directly
            if echo "$build_output" | grep -q "hash mismatch"; then
                echo_warning "Hash mismatch detected in $file"

                # Extract both specified and got hashes from build output
                # Look for patterns like "specified: sha256-..." or "specified: sha256:..."
                specified_hash=$(echo "$build_output" | grep -oE "specified:.*sha256[:-][A-Za-z0-9+/=]+" | sed 's/specified:[[:space:]]*//' | head -1)
                got_hash=$(echo "$build_output" | grep -oE "got:.*sha256[:-][A-Za-z0-9+/=]+" | sed 's/got:[[:space:]]*//' | head -1)

                if [[ -n $specified_hash && -n $got_hash ]]; then
                    echo_info "Replacing hash in $file:"
                    echo -e "  ${YELLOW}Old:${NC} $specified_hash"
                    echo -e "  ${GREEN}New:${NC} $got_hash"

                    # Use a more robust replacement approach
                    # First, try to find and replace the exact hash string
                    if grep -q "$specified_hash" "$file"; then
                        sed -i.bak "s|$specified_hash|$got_hash|g" "$file"
                        rm -f "$file.bak"
                        echo_success "Successfully updated hash in $file"
                    else
                        echo_warning "Could not find specified hash in $file"
                        echo_info "Searching for similar hashes..."
                        grep -n "sha256" "$file" || true
                    fi
                else
                    echo_warning "Could not extract both specified and got hashes from build output for $file"
                    echo "Specified: '$specified_hash'"
                    echo "Got: '$got_hash'"
                    echo "Raw build output:"
                    echo "$build_output" | grep -A5 -B5 "hash mismatch" || true
                fi
            fi
        done
    else
        if [[ ${#target_items[@]} -gt 0 ]]; then
            echo_info "No files were changed by $operation_name for items: ${target_items[*]}"
        else
            echo_info "No files were changed by $operation_name"
        fi
    fi

    rm -rf result
    rm -rf result-*
}

function tool:pkgs:fetchgit {
    local target_items=("$@")

    echo_header "Updating nix pkgs with fetchgit"
    pushd "$NIX_CONFIG_PATH"

    if [[ ${#target_items[@]} -gt 0 ]]; then
        echo_info "Running update-nix-fetchgit on specified items: ${target_items[*]}"
        for item in "${target_items[@]}"; do
            # Convert dot notation to path (e.g., "fish-plugins.upto" -> "fish-plugins/upto")
            item_path="${item//\.//}"
            item_dir="pkgs/$item_path"
            if [[ -d $item_dir ]]; then
                find "$item_dir" -type f -name "*.nix" -print0 | xargs -0 -I '{}' sh -c 'update-nix-fetchgit {} 2>&1 || true'
            else
                echo_warning "Directory $item_dir not found"
            fi
        done
    else
        # Run update-nix-fetchgit on all .nix files
        echo_info "Running update-nix-fetchgit on all .nix files..."
        find pkgs -type f -name "*.nix" -print0 | xargs -0 -I '{}' sh -c 'update-nix-fetchgit {} 2>&1 || true'
    fi

    # Update hashes for any changed files
    tool:pkgs:hashes "update-nix-fetchgit" "${target_items[@]}"

    echo_success "Fetchgit update complete"
    popd
}

function tool:pkgs:update {
    local target_packages=("$@")

    echo_header "Updating packages with nix-update"
    pushd "$NIX_CONFIG_PATH"

    # Get the current system
    system=$(nix eval --impure --raw --expr 'builtins.currentSystem')

    # Collect all packages and plugins to update
    local all_items=()

    if [[ ${#target_packages[@]} -gt 0 ]]; then
        all_items=("${target_packages[@]}")
        echo_info "Updating specified packages: ${all_items[*]}"
    else
        # Get list of available packages
        local packages=($(nix eval --json ".#packages.$system" --apply 'builtins.attrNames' | jq -r '.[]'))

        for package in "${packages[@]}"; do
            # Check if this is a plugin collection (fish-plugins or tmux-plugins)
            if [[ $package == "fish-plugins" || $package == "tmux-plugins" ]]; then
                # Get individual plugins from the collection
                local plugins=($(nix eval --json ".#packages.$system.$package" --apply 'builtins.attrNames' | jq -r '.[]'))
                for plugin in "${plugins[@]}"; do
                    all_items+=("$package.$plugin")
                done
            else
                # Regular package
                all_items+=("$package")
            fi
        done

        echo_info "Found ${#all_items[@]} items to update (packages + plugins)..."
    fi

    failed_items=()
    successful_items=()

    for item in "${all_items[@]}"; do
        echo_info "Attempting to update: $item"

        # Determine the flake attribute path based on item type
        local attr_path=""
        if [[ $item == *"."* ]]; then
            # Plugin format: fish-plugins.upto or tmux-plugins.fingers
            attr_path="packages.$system.$item"
        else
            # Regular package
            attr_path="packages.$system.$item"
        fi

        # Check if item exists in the flake
        if ! nix eval ".#$attr_path" &> /dev/null; then
            echo_warning "Item $item not found in flake, skipping..."
            continue
        fi

        # Check if package has subpackages by looking for buildGoModule, buildNpmPackage, etc.
        package_file=$(nix eval --json ".#$attr_path.meta.position" 2> /dev/null | jq -r '.' | cut -d: -f1 2> /dev/null || echo "")

        update_args="--flake --version=branch"

        # Add subpackage flags for packages that commonly have them
        if [[ -n $package_file && -f $package_file ]]; then
            # Check for common subpackage patterns
            if grep -q "buildGoModule\|buildNpmPackage\|buildRustPackage" "$package_file" 2> /dev/null; then
                # Look for attribute assignments that might be subpackages
                subpackages=$(grep -E "^\s*[a-zA-Z][a-zA-Z0-9_-]*\s*=\s*build(Go|Npm|Rust)Module" "$package_file" | sed -E 's/^\s*([a-zA-Z][a-zA-Z0-9_-]*)\s*=.*/\1/' | grep -v "^src$" | grep -v "^version$" | grep -v "^pname$" | grep -E "^[a-zA-Z][a-zA-Z0-9_-]*$" || true)

                for subpkg in $subpackages; do
                    if [[ $subpkg != "${item##*/}" && -n $subpkg ]]; then
                        update_args="$update_args --subpackage $subpkg"
                    fi
                done
            fi
        fi

        if timeout 300 nix-update $update_args "$attr_path" &> /dev/null; then
            echo_success "Successfully updated $item"
            successful_items+=("$item")
        else
            echo_error "Failed to update $item"
            failed_items+=("$item")
        fi
    done

    # Update hashes only for successfully updated items
    if [[ ${#successful_items[@]} -gt 0 ]]; then
        echo_info "Updating hashes for ${#successful_items[@]} successfully updated items: ${successful_items[*]}"
        tool:pkgs:hashes "nix-update" "${successful_items[@]}"
    else
        echo_warning "No items were successfully updated with nix-update, skipping hash updates"
    fi

    # Fallback to fetchgit if any items failed to update with nix-update
    if [[ ${#failed_items[@]} -gt 0 ]]; then
        echo_info "Running fetchgit on ${#failed_items[@]} failed items: ${failed_items[*]}"
        tool:pkgs:fetchgit "${failed_items[@]}"
    else
        echo_success "All items updated successfully with nix-update"
    fi

    popd
}

function tool:brew {
    if command -v brew &> /dev/null; then
        echo_header "Updating homebrew packages"
        echo_info "Updating brew formulae..."
        brew update
        echo_info "Upgrading packages..."
        brew upgrade --greedy
        echo_success "Homebrew packages updated"
    else
        echo_warning "Homebrew not found, skipping"
    fi
}

function tool:brew:clean {
    if command -v brew &> /dev/null; then
        echo_header "Cleaning homebrew cache"
        brew cleanup --prune=7
        echo_success "Homebrew cache cleaned"
    else
        echo_warning "Homebrew not found, skipping"
    fi
}

function tool:fish {
    echo_header "Updating fish completions"
    fish -c 'fish_update_completions'
    echo_success "Fish completions updated"
}

function tool:fish:clean {
    echo_header "Cleaning fish frozen files"
    rm -f "${HOME}/.config/fish/conf.d/fish_frozen_key_bindings.fish"
    rm -f "${HOME}/.config/fish/conf.d/fish_frozen_theme.fish"
    echo_success "Fish frozen cleaned"
}

function tool:misc:clean {
    echo_header "Cleaning miscellaneous"
    # rm -f "${HOME}/.cache/opencode/models.json"
    echo_success "Miscellaneous cleaned"
}

function tool:clean {
    echo_header "Cleaning up"
    tool:nvim:clean
    tool:nix:clean
    tool:fish:clean
    if [[ $OS == "darwin" ]]; then
        tool:brew:clean
    fi
    tool:misc:clean
    echo_success "Cleanup complete"
}

function tool:restore {
    echo_header "Restoring system"
    tool:nvim:restore
    tool:nix:rebuild
    tool:clean
    echo_success "System restore complete"
}

function tool:all {
    echo_header "Running complete system update"
    tool:config
    tool:nvim
    tool:nix
    if [[ $OS == "darwin" ]]; then
        tool:brew
    fi
    tool:clean
    echo_success "üéâ Complete system update finished!"
}

function tool:list {
    compgen -A function | sed -rn 's/tool:(.*)/\1/p' | cat
}

function tool:help {
    echo_header "Update Script Help"
    printf "${BOLD}Usage:${NC} %s [TOOL] [ARGS]\n\n" "$0"
    echo -e "${BOLD}Available Tools:${NC}"

    local tools=($(compgen -A function | sed -rn 's/tool:(.*)/\1/p'))
    for i in "${!tools[@]}"; do
        local tool="${tools[$i]}"
        local emoji=""
        case "$tool" in
            "all") emoji="üöÄ" ;;
            "config") emoji="‚öôÔ∏è" ;;
            "nvim"*) emoji="üìù" ;;
            "nix"*) emoji="‚ùÑÔ∏è" ;;
            "brew") emoji="üç∫" ;;
            "fish") emoji="üêü" ;;
            "clean") emoji="üßπ" ;;
            "restore") emoji="üîÑ" ;;
            "help") emoji="‚ùì" ;;
            "list") emoji="üìã" ;;
            *) emoji="üîß" ;;
        esac
        printf "  ${CYAN}%2d.${NC} ${emoji} ${BOLD}%s${NC}\n" $((i + 1)) "$tool"
    done
}

"tool:${@:-all}"
